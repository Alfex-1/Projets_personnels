library(MASS)
modele.back <- step(object = modele.complet,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "backward")
modele.back
formula(modele.back$model) #le modèle optimal obtenu
#la méthode forward selection
modele.forward <- step(object = modele.trivial,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "forward")
modele.forward
formula(modele.forward$model) #le modèle optimal obtenu
#la méthode bidirectional elimination
modele.bidirect.elim <- step(object = modele.complet,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "both")
modele.bidirect.elim
formula(modele.bidirect.elim$model) #le modèle optimal obtenu
#la méthode bidirectional selection
modele.bidirect.select <- step(object = modele.trivial,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "both")
modele.bidirect.select
formula(modele.bidirect.select$model) #le modèle optimal obtenu
#les 4 algorithmes précédents donne le même modèle.
#### Sélection de modèles (de variables) selon le critère BIC par algorithmes de recherche pas-à-pas ####
modele.complet <- multinom(formula = Species ~ . , data = iris, model = TRUE, maxit = 3000)
modele.trivial <- multinom(formula = Species ~ 1, data = iris, model = TRUE, maxit = 3000)
n <- nrow(iris) #nombre d'observation
#la méthode backward elimination
modele.back <- step(object = modele.complet,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "backward", k = log(n))
modele.back
formula(modele.back$model) #le modèle optimal obtenu
#la méthode forward selection
modele.forward <- step(object = modele.trivial,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "forward", k = log(n))
modele.forward
formula(modele.forward$model) #le modèle optimal obtenu
#la méthode bidirectional elimination
modele.bidirect.elim <- step(object = modele.complet,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "both", k = log(n))
modele.bidirect.elim
formula(modele.bidirect.elim$model) #le modèle optimal obtenu
#la méthode bidirectional selection
modele.bidirect.select <- step(object = modele.trivial,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "both", k = log(n))
modele.bidirect.select
formula(modele.bidirect.select$model) #le modèle optimal obtenu
#les 4 algorithmes précédents donne le même modèle.
#Les deux critères AIC et BIC donne le même modèle.
#################################################################################
#### Tests d'hypothèses par maximum de vraisemblance dans le modèle de RegLogMultinom ####
#Nous allons considérer le modèle optimal sélectionné selon le critère AIC
#i.e., le modèle Species ~ Petal.Width + Petal.Length + Sepal.Width
#on crée d'abord le sous-ensemble de données correspondant
iris.opt.data <- iris[,!(colnames(iris)=="Sepal.Length")]
View(iris.opt.data)
View(iris)
#### Test de validité du modèle global : H_0 : w_2 = w_3 = (0,0,0) ####
modele <-  multinom(formula = Species ~  ., data = iris.opt.data, maxit = 3000)
modele
modele.reduit <- multinom(formula = Species ~ 1, data = iris.opt.data, maxit = 3000)
Sn <- modele.reduit$deviance-modele$deviance #la statistique du rapport de vraisemblance
print(Sn)
d <- modele$edf - modele.reduit$edf  #donne le n ddl de la loi du chi2 asymptotique de la stat Sn
pvalue <- pchisq(q = Sn, df = d, lower.tail = F)
print(pvalue) #on obtient  2.601647e-65, le modèle optimal est très significatif
#### Tester si la variable Sepal.Width n'est pas significative dans le modèle : H_0 : w_{2,1} = w_{3,1} = 0 ####
modele <-  multinom(formula = Species ~  ., data = iris.opt.data, maxit = 3000)
modele.reduit <- multinom(formula = Species ~ .,
data = iris.opt.data[, !(colnames(iris.opt.data)=="Sepal.Width")],
maxit = 2000) #le modèle réduit
Sn <- modele.reduit$deviance - modele$deviance
print(Sn)
d <- modele$edf - modele.reduit$edf  #donne le n ddl de la loi du chi2 asymptotique de la stat Sn
pvalue.Sepal.Width <- pchisq(q = Sn, df = d, lower.tail = F)
print(pvalue.Sepal.Width)
#Tester si la variable Petal.Length n'est pas significative : H_0 = w_{2,2} = w_{3,2} = 0
modele.reduit <- multinom(formula = Species ~ .,
data = iris.opt.data[, !(colnames(iris.opt.data)=="Petal.Length")],
maxit = 2000) #le modèle réduit
Sn <- modele.reduit$deviance - modele$deviance
print(Sn)
d <- modele$edf - modele.reduit$edf  #donne le n ddl de la loi du chi2 asymptotique de la stat Sn
pvalue.Petal.Length <- pchisq(q = Sn, df = d, lower.tail = F)
print(pvalue.Petal.Length)
#Tester si la variable Petal.Width n'est pas significative : H_0 = w_{2,3}=w_{3,3}=0
modele.reduit <- multinom(formula = Species ~ .,
data = iris.opt.data[, !(colnames(iris.opt.data)=="Petal.Width")],
maxit = 2000) #le modèle réduit
Sn <- modele.reduit$deviance - modele$deviance
print(Sn)
d <- modele$edf - modele.reduit$edf  #donne le n ddl de la loi du chi2 asymptotique de la stat Sn
pvalue.Petal.Width <- pchisq(q = Sn, df = d, lower.tail = F)
print(pvalue.Petal.Width)
#### Classer les variables ####
pvalues <- c(pvalue.Sepal.Width, pvalue.Petal.Length, pvalue.Petal.Width)
names(pvalues) <- colnames(iris.opt.data[, !(colnames(iris.opt.data) == "Species")])
variables.classees <- sort(pvalues)
print(variables.classees) # on obtient le classement suivant :
#Petal.Width Petal.Length  Sepal.Width
#0.0001089506 0.0008533257 0.0259165680
#################################################################################################
#### Erreurs de classification, évaluées par validation croisées,
#pour le modèle optimal selon AIC (réduit aux trois variables Sepal.Width, Petal.Length et Petal.Width),
#et pour le modèle complet utilisant les quatre variables ####
indices <- 1:nrow(iris)
#la fonction évaluant l'erreur de classification des deux modèles, pour une partition donnée
err_classif <- function(l = 3){
#on partage le tableau en deux parties : par exemple (l-1)/l pour apprentissage et 1/l pour le test
indices.ensemble.test <- sample(indices, trunc(length(indices)/l), replace = FALSE)
ensemble.test <- iris[indices.ensemble.test, ]
ensemble.apprentissage <- iris[-indices.ensemble.test, ]
modele.AIC <- multinom(formula = Species ~ Sepal.Width+Petal.Length+Petal.Width,
data = ensemble.apprentissage, maxit = 3000) # le modèle optimal
modele.complet <- multinom(formula = Species ~ .,
data = ensemble.apprentissage, maxit = 3000) # le modèle complet
pred.moda.modele.AIC <- predict(object = modele.AIC, newdata = ensemble.test)
pred.moda.modele.complet <- predict(object = modele.complet, newdata = ensemble.test)
erreur.modele.AIC <- mean(!(pred.moda.modele.AIC == ensemble.test$Species))
erreur.modele.complet <- mean(!(pred.moda.modele.complet == ensemble.test$Species))
return(c(erreur.modele.AIC, erreur.modele.complet))
}
print(err_classif(3))
#on applique la fonction précédente M = 100 fois, à l'aide de la fonction ``replicate'',
#et on met les résultats dans le tableau resultats, de dimension 2xM,
#cela évite l'utilisation de boucles for.
M <- 100 #nombre de réplications
resultats <- replicate(M, err_classif(3))
resutats.moyens <- apply(resultats,1,mean) #on calcule la moyenne par colonne
err.classif.modele.AIC <- resutats.moyens[1]
err.classif.modele.complet <- resutats.moyens[2]
err.classif.modele.AIC
err.classif.modele.complet
#on obtient des résultats comparables, pour cet exemple, l'erreur de classification est de 4% en moyenne pour les deux modèles,
#le modèle optimal est quand même mieux, car utilise peu de variables, par rapport au modèle complet, et prédit avec efficacité comparable ...
modele.back <- step(object = modele.complet,
scope = list(lower = Species ~ 1, upper = formula(modele.complet$model)),
direction = "backward", k = log(n))
modele.back
formula(modele.back$model)
err.classif.modele.complet <- resutats.moyens[2]
err.classif.modele.AIC
err.classif.modele.complet
install.packages(c("bookdown", "checkmate", "collapse", "emmeans", "evaluate", "httpuv", "knitr", "magick", "markdown", "performance", "rbibutils", "RcppArmadillo", "utf8", "withr", "xfun"))
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
library(ISLR)
install.packages("rpart")
install.packages("rattle")
library(rpart)
library(rattle)
library(testhp)
?testhp
testhp(0.9)
rm(list=ls())
library(kernlab)
data(spam)
str(spam) #57 variables explicatives numériques
# + une variable catégorielle "type" à deux modalités "nonspam", "spam"
library(keras)
library(tensorflow)
spamX <- as.matrix(spam[,-58])
#la variable catégorielle doit être mise sous forme disjonctive
spamY <- to_categorical(as.numeric(spam$type)-1, num_classes=2)
str(spamY)
summary(spamY)
#découpage en ensemble d'apprentissage et en ensemble de test
set.seed(5678)
perm <- sample(4601,3000) #Création un vecteur qui contient
#un échantillon aléatoire de 3000 indices parmi les valeurs de 1 à 4601.
#Cela sera utilisé pour sélectionner un sous-ensemble aléatoire d'observations
#de l'ensemble de données original.
appX <- spamX[perm,]
appY <- spamY[perm,]
testX <- spamX[-perm,]
testY <- spamY[-perm,]
#### Modèle simple : à une couche ####
# avec nombre de neurones : units=2
set_random_seed(42)
mod.1couche <- keras_model_sequential() %>%
layer_dense(units=2, activation ="softmax")
#les différents neuronnes permettent d'estimer les probabilités conditionnelles
mod.1couche %>% compile(loss = "categorical_crossentropy",
optimizer=optimizer_rmsprop(),
metrics=c("accuracy"))
#on peut donc réestimer les paramètres du réseau en utilisant toutes les données d'apprentissage
# en spécifiant validation_split=0, (avec nombre d'epochs = 30) :
rm(mod.1couche)
mod.1couche <- keras_model_sequential() %>%
layer_dense(units=2, activation ="softmax") #la couche de sortie doit OBLIGATOIREMENT
#poids synaptiques estimés
get_weights(mod.1couche)
install.packages(c("collapse", "DBI", "GGally", "magick", "parallelly", "parsnip", "performance", "quantmod", "V8"))
library(xgboost)
library(reshape2)
library(pbkrtest)
library(gbm)
library(bslib)
library(bit)
library(BH)
library(boot, lib.loc = "C:/Program Files/R/R-4.3.2/library")
library(bookdown)
library(forecast)
library(foreign, lib.loc = "C:/Program Files/R/R-4.3.2/library")
library(forestmodel)
library(Formula)
library(fracdiff)
library(foreach)
library(forcats)
library(fontquiver)
library(fontLiberation)
library(fontBitstreamVera)
library(fontawesome)
library(flexdashboard)
library(flashClust)
library(fastmap)
library(farver)
library(fansi)
library(Factoshiny)
library(FactoMineR)
library(FactoInvestigate)
library(factoextra)
library(extrafont)
library(extrafontdb)
library(expm)
library(Exact)
library(evaluate)
library(estimability)
library(esquisse)
library(emmeans)
library(ellipsis)
library(ellipse)
library(effectsize)
library(effects)
library(e1071)
library(dtplyr)
library(DT)
library(dplyr)
library(downlit)
library(doParallel)
library(distributional)
library(digest)
library(diffobj)
library(DiceDesign)
library(dials)
library(diagram)
library(devtools)
library(deux)
library(DescTools)
library(desc)
library(abind)
library(anytime)
library(aod)
library(arrow)
library(askpass)
library(assertthat)
library(backports)
library(bayestestR)
library(bdsmatrix)
library(bigD)
library(bit64)
library(bitops)
library(blob)
library(brew)
library(brio)
library(broom)
library(broom.helpers)
library(cachem)
library(Cairo)
library(callr)
library(car)
library(caret)
library(caTools)
library(cellranger)
library(checkmate)
library(cli)
library(clipr)
library(clock)
library(class, lib.loc = "C:/Program Files/R/R-4.3.2/library")
library(clubSandwich)
library(cluster, lib.loc = "C:/Program Files/R/R-4.3.2/library")
library(codetools, lib.loc = "C:/Program Files/R/R-4.3.2/library")
library(collapse)
library(colorspace)
library(colourpicker)
library(commonmark)
library(compiler, lib.loc = "C:/Program Files/R/R-4.3.2/library")
library(config)
library(conflicted)
library(corrplot)
library(cowplot)
library(cpp11)
library(cranlogs)
library(crayon)
library(credentials)
library(crul)
library(crosstalk)
library(curl)
library(data.table)
library(datamods)
library(datawizard)
library(DBI)
library(dendextend)
library(fs)
library(furrr)
detach("package:future", unload = TRUE)
library(future.apply)
library(gargle)
library(future)
library(gdtools)
library(generics)
library(gert)
library(gfonts)
library(GGally)
library(ggdist)
library(gghalves)
library(gglasso)
library(ggpubr)
library(ggrepel)
library(ggsci)
library(ggsignif)
library(ggstats)
library(ggtext)
library(gh)
library(gld)
library(gitcreds)
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
install.packages(c("arrow", "dials", "gdtools", "ggplot2", "renv", "shape"))
install.packages("deSolve")
library(deSolve)
library(ggplot2)
# Fonction représentant les équations différentielles du modèle
deriv <- function(t, y, parms) {
with(as.list(c(y, parms)), {
dSdt <- -beta * S * I * exp(-gamma)
dIdt <- beta * S * I * exp(-gamma) - alpha * I
dRdt <- alpha * I
return(list(c(dSdt, dIdt, dRdt)))
})
}
# Paramètres du modèle
parms <- c(beta = 0.3, gamma = 0.1, alpha = 0.05)
# Conditions initiales
y0 <- c(S = N - 1, I = 1, R = 0)
library(deSolve)
library(ggplot2)
# Fonction représentant les équations différentielles du modèle
deriv <- function(t, y, parms) {
with(as.list(c(y, parms)), {
dSdt <- -beta * S * I * exp(-gamma * t)
dIdt <- beta * S * I * exp(-gamma * t) - alpha * I
dRdt <- alpha * I
return(list(c(dSdt, dIdt, dRdt)))
})
}
# Paramètres du modèle
N <- 1000  # Nombre total de nœuds dans le réseau
parms <- c(beta = 0.3, gamma = 0.1, alpha = 0.05)
# Conditions initiales
y0 <- c(S = N - 1, I = 1, R = 0)
# Temps
times <- seq(0, 100, by = 1)  # De 0 à 100 unités de temps
# Résolution des équations différentielles
output <- ode(y = y0, times = times, func = deriv, parms = parms)
# Conversion des résultats en un objet data.frame pour une utilisation facile avec ggplot2
result_df <- as.data.frame(output)
# Affichage des résultats avec ggplot2
ggplot(result_df, aes(x = time)) +
geom_line(aes(y = S, color = "Susceptibles")) +
geom_line(aes(y = I, color = "Infectés")) +
geom_line(aes(y = R, color = "Récupérés")) +
labs(x = "Temps", y = "Nombre de nœuds", color = "Statut") +
theme_minimal()
install.packages(c("deSolve", "ggplot2"))
install.packages(c("deSolve", "ggplot2"))
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
gc()
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
install.packages("rpart.plot")
install.packages(c("data.table", "datamods", "FactoMineR", "parallelly", "RcppEigen", "renv", "shinyWidgets"))
install.packages(c("bdsmatrix", "bookdown", "curl", "forecast", "ggsci", "hrbrthemes", "RcppArmadillo"))
install.packages(c("gdtools", "ggdist", "lava", "rmarkdown"))
install.packages("rmarkdown")
install.packages(c("globals", "multcompView", "rmarkdown", "shinybusy", "survey", "systemfonts"))
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
install.packages(c("arrow", "bookdown", "brio", "broom.helpers", "bslib", "callr", "collapse", "crul", "data.table", "datamods", "datawizard", "digest", "DT", "effectsize", "emmeans", "FactoMineR", "Factoshiny", "fs", "future", "future.apply", "gglasso", "ggplot2", "ggsci", "ggstats", "gh", "gtable", "htmltools", "httpuv", "httr2", "infer", "insight", "keras", "knitr", "labelled", "lme4", "matrixStats", "maxLik", "munsell", "mvnormtest", "openssl", "parameters", "parsnip", "performance", "phosphoricons", "pkgbuild", "pkgdown", "plm", "processx", "promises", "psych", "ragg", "RcppArmadillo", "remotes", "renv", "reticulate", "rsample", "rstudioapi", "sass", "shiny", "shinyWidgets", "survey", "tensorflow", "testthat", "tfruns", "tidymodels", "tidyselect", "tinytex", "tune", "workflowsets", "xfun", "xopen", "yardstick"))
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
warnings()
install.packages(c("ragg", "RcppArmadillo", "stringi", "tinytex"))
install.packages(c("backports", "broom", "cachem", "collapse", "datamods", "effectsize", "emmeans", "esquisse", "estimability", "farver", "fastmap", "ggsci", "insight", "minqa", "mvtnorm", "openssl", "parameters", "ragg", "reticulate", "rio", "rmarkdown", "systemfonts", "textshaping", "tseries", "xfun"))
library(tseries)
# Installation du package "installr" s'il n'est pas déjà installé
if (!require(installr)) {
install.packages("installr")
}
# Chargement du package "installr"
library(installr)
# Vérification des mises à jour disponibles pour R
check.for.updates.R()
# Mise à jour de R
updateR()
install.packages(c("arrow", "datawizard", "DBI", "hardhat", "highr", "insight", "knitr", "markdown", "quantreg", "RcppArmadillo", "rio", "rlang", "SparseM", "urca", "xts"))
install.packages(c("downlit", "evaluate", "insight", "leaps", "performance"))
install.packages(c("cli", "clubSandwich", "crayon", "forecast", "ggsci", "lme4", "modeldata", "nloptr", "parameters", "reticulate", "xfun"))
install.packages(c("cli", "clubSandwich", "crayon", "forecast", "ggsci", "lme4", "modeldata", "nloptr", "parameters", "reticulate", "xfun"))
install.packages("cli")
install.packages("cli")
install.packages(c("cli", "digest", "nloptr", "prodlim", "reactR", "SparseM", "ucminf", "XML"))
install.packages(c("cli", "digest", "nloptr", "prodlim", "reactR", "SparseM", "ucminf", "XML"))
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages(c("bookdown", "cli", "collapse", "datawizard", "effectsize", "emmeans", "gbm", "gt", "httr2", "insight", "ipred", "knitr", "lhs", "lme4", "magick", "pbkrtest", "performance", "pkgdown", "pkgload", "ps", "psych", "Rcpp", "RcppArmadillo", "recipes", "report", "reprex", "roxygen2", "SparseM", "tinytex", "xfun", "yaml"))
install.packages(c("bookdown", "cli", "collapse", "datawizard", "effectsize", "emmeans", "gbm", "gt", "httr2", "insight", "ipred", "knitr", "lhs", "lme4", "magick", "pbkrtest", "performance", "pkgdown", "pkgload", "ps", "psych", "Rcpp", "RcppArmadillo", "recipes", "report", "reprex", "roxygen2", "SparseM", "tinytex", "xfun", "yaml"))
install.packages("cli")
install.packages("cli")
setwd("C:/Projets_personnels/Ventes_magasin")
# Fonction pour installer un package spécifique
install_package_version <- function(package, version) {
# Construire l'URL pour télécharger le package
url <- sprintf("https://cran.r-project.org/src/contrib/Archive/%s/%s_%s.tar.gz", package, package, version)
install.packages(url, repos = NULL, type = "source")
}
# Lire le fichier texte
packages <- readLines("requirements_R.txt")
# Installer les packages avec les versions spécifiées
for (pkg in packages) {
# Séparer le nom du package et la version
pkg_parts <- strsplit(pkg, "==")[[1]]
package <- pkg_parts[1]
version <- pkg_parts[2]
# Installer le package avec la version spécifiée
install_package_version(package, version)
}
# Lire le fichier texte
packages <- readLines("requirements_R.txt")
# Installer les packages
install.packages(packages)
# Lire le fichier texte
packages <- readLines("requirements_R.txt")
# Installer les packages
install.packages(packages)
